= {project-name} - Deploying an Application to Kubernetes and OpenShift

This guide covers:

* The deployment of the application to Kubernetes
* The deployment of the application to OpenShift (TODO)

== Prerequisites

To complete this guide, you need:

* roughly 15 minutes
* an IDE
* JDK 1.8+ installed with `JAVA_HOME` configured appropriately
* Apache Maven 3.5.3+
* access to a Kubernetes or OpenShift cluster (Minikube and Minishift are both viable options)
* have the following binaries on your PATH: `docker` (for building and pushing images), `kubectl` (for deploying to Kubernetes) and `oc` (for deploying to OpenShift)

== Creating the Maven project

First, we need a new project that contains the kubernetes extension. This can be done using the following command:

[source, subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:${quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=test \
    -DclassName="org.acme.rest.GreetingResource" \
    -Dpath="/greeting" \
    -Dextensions="kubernetes"
----

== Enable Kubernetes support

{project-name} offers the ability to automatically generate Kubernetes resources based on sane defaults and user supplied configuration. The implementation that takes care
of generating the actual Kubernetes resources is provided by https://github.com/ap4k/ap4k/[ap4k].

When we added the `kubernetes` extension to the command line invocation above, the following dependency was added to the `pom.xml`

[source,xml]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-kubernetes</artifactId>
    </dependency>
----

By adding this dependency, we now have the ability to configure the Kubernetes resource generation and application using the usual `application.properties` approach that {project-name} provides.
The configuration items that are available can be found in: `io.quarkus.kubernetes.deployment.KubernetesConfig` class.
Furthermore, the items provided by `io.quarkus.deployment.ApplicationConfig` affect the Kubernetes resources.

By using the following configuration for example:

[source]
----
quarkus.application.group=yourDockerUsername # this is optional and defaults to the project group if not set
quarkus.application.name=test-quarkus-app # this is also optional and defaults to the project name if not set
----

and following the execution of `mvn package` you will notice amongst the other files that are created, two files named
`kubernetes.json` and `kubernetes.yaml` in the `target/wiring-classes/META-INF/ap4k/` directory.

If you look at either file you will see that it contains both a Kubernetes `Deployment` and a `Service`.

The full source of the `kubernetes.json` file looks something like this:

[source,json]
----
{
  "apiVersion" : "v1",
  "kind" : "List",
  "items" : [ {
    "apiVersion" : "apps/v1",
    "kind" : "Deployment",
    "metadata" : {
      "labels" : {
        "app" : "test-quarkus-app",
        "version" : "1.0-SNAPSHOT",
        "group" : "yourDockerUsername"
      },
      "name" : "test-quarkus-app"
    },
    "spec" : {
      "replicas" : 1,
      "selector" : {
        "matchLabels" : {
          "app" : "test-quarkus-app",
          "version" : "1.0-SNAPSHOT",
          "group" : "yourDockerUsername"
        }
      },
      "template" : {
        "metadata" : {
          "labels" : {
            "app" : "test-quarkus-app",
            "version" : "1.0-SNAPSHOT",
            "group" : "yourDockerUsername"
          }
        },
        "spec" : {
          "containers" : [ {
            "env" : [ {
              "name" : "KUBERNETES_NAMESPACE",
              "valueFrom" : {
                "fieldRef" : {
                  "fieldPath" : "metadata.namespace"
                }
              }
            } ],
            "image" : "yourDockerUsername/test-quarkus-app:1.0-SNAPSHOT",
            "imagePullPolicy" : "IfNotPresent",
            "name" : "test-quarkus-app"
          } ]
        }
      }
    }
  } ]
}
----

An important thing to note about the `Deployment` is that is uses `yourDockerUsername/test-quarkus-app:1.0-SNAPSHOT` as the Docker image of the `Pod`.

Also the `Service` is configured to use container port `8080` (which is automatically picked up by the standard Quarkus configuration).

An important thing to keep in mind is that so far, all {project-name} has done is generate the `Kubernetes` resources, it has not applied them. The next section will walk you through how this can be done.

== Closing the Kubernetes / Docker loop

For this section of the guide it is assumed that both `docker` and `kubectl` binaries are present on the PATH, that you have logged into `docker.io` with `yourDockerUsername` using `docker login` and finally that
`kubectl` can properly interact with the Kubernetes cluster you are using.

Note that when the project was first created, a Dockerfile named `Dockerfile.jvm` was created at `src/main/docker`. This Dockerfile is automatically used to build the docker image.

If you start out by simply executing `mvn clean package -Dquarkus.kubernetes.docker.build=true` then at the end of the build you have a `yourDockerUsername/test-quarkus-app:1.0-SNAPSHOT` image built locally that can be run like so:

`docker run --rm -p 8080:8080 yourDockerUsername/test-quarkus-app:1.0-SNAPSHOT`

To actually deploy your application onto your Kubernetes cluster, you need to execute `mvn clean package -Dquarkus.kubernetes.docker.push=true -Dquarkus.kubernetes.deploy=true`.

In addition to what the previous command did, this command also pushes the image to the registry and applies the Kubernetes resources. At the end of the process the application will be deployed onto the cluster.

When you are done with using the application, you can remove it from the Kubernetes cluster by simply executing `kubectl delete -f target/wiring-classes/META-INF/ap4k/kubernetes.json`



[NOTE]
====
The configutation items used above (`quarkus.kubernetes.docker.build`, `quarkus.kubernetes.docker.push` and `quarkus.kubernetes.deploy`) can of course be added to `application.properties`.
Overriding them during build time as we have shown above works the same as any other {project-name} property.
====


== Using Gradle

In order to be able to utilize the full capabilities of ap4k when using the {project-name} Gradle plugin instead of the Maven plugin,
all tasks executions need to be performed using the `--no-daemon` flag.
The reason this is needed is because ap4k invokes the `docker`, `kubectl` and `oc` binaries as part of JVM shutdown hooks (which in turn is done
because ap4k needs to have access to the final `*-runner` jar that is constructed when the build process completes).
When running Gradle without the `--no-daemon` flag, Gradle does not shutdown the JVM thus preventing the hooks from executing.