include::./attributes.adoc[]
= {project-name} - Asynchronous messages between beans

{project-name} allows different beans to interact using asynchronous messages, enforcing loose-coupling.
The messages are sent to _virtual addresses_.
It offers 3 types of delivery mechanism:

- point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round robin is applied;
- publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;
- request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion

All these delivery mechanism are non-blocking, and are providing one of the fundamental brick to build reactive applications.

== Installing

This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` extension to use this feature.
If you are creating a new project, set the `extensions` parameter are follows:

[source, subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=vertx-quickstart \
    -Dextensions="vertx"
----

If you have an already created project, the `vertx` extension can be added to an existing {project-name} project with
the `add-extension` command:

[source]
----
mvn quarkus:add-extension -Dextensions="vertx"
----

Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:

[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-vertx</artifactId>
</dependency>
----

== Consuming events

To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:

[source, java]
----
package org.acme;

import io.quarkus.vertx.ConsumeEvent;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class NameService {

    @ConsumeEvent                           // <1>
    public String consume(String name) {    // <2>
        return name.toUpperCase();
    }
}
----
<1> If not set, the address is the fully qualified name of the bean, for instance, in this snippet it's `org.acme.NameService`
<2> The method parameter is the message body. If the method returns _something_ it's the message response.

=== Configuring the address

The `@ConsumeEvent` annotation can be configured to set the address:

[source, java]
----
@ConsumeEvent("my-address")
public String consume(String name) {
    return name.toUpperCase();
}
----

=== Consuming without replying

In the previous examples, the consumer returns a result, but it's not necessary:

[source,java]
----
@ConsumeEvent("my-address")
public void consume(String event) {
    // Do something with the event
}
----

=== Replying

The _return_ of a method annotated with `@ConsumeEvent` is used as response to the incoming message.
For instance, in the following snippet, the returned `String` is the response.

[source, java]
----
@ConsumeEvent("my-address")
public String consume(String name) {
    return name.toUpperCase();
}
----

You can also return a `CompletionStage<T>` to handle asynchronous reply:

[source, java]
----
@ConsumeEvent("my-address")
public CompletionStage<String> consume2(String name) {
    return CompletableFuture.supplyAsync(name::toUpperCase);
}
----

=== Dealing with messages

As said above, this mechanism is based on the Vert.x event bus. So, you can also use `Message` directly:

[source, java]
----
@ConsumeEvent("my-address")
public void consume(Message<String> msg) {
    System.out.println(msg.address());
    System.out.println(msg.body());
}
----

== Sending messages

Ok, we have seen how to receive messages, let's now switch to the _other side_: the sender.
Sending and publishing messages use the Vert.x event bus:

[source, java]
----
package org.acme;

import io.vertx.axle.core.eventbus.EventBus;
import io.vertx.axle.core.eventbus.Message;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import java.util.concurrent.CompletionStage;

@Path("/async")
public class EventResource {

  @Inject EventBus bus;                                                        // <1>

  @GET
  @Path("/{name}")
  public CompletionStage<String> hello(@PathParam("name") String name) {
      return bus.<String>send("my-address", name)                             // <2>
              .thenApply(Message::body);
  }
}
----
<1> Inject the Event bus
<2> Send a message to the address `my-address`. Message payload is `name`

The `EventBus` object provides methods to:

1. `send` a message to a specific address - one single consumer receives the message.
2. `publish` a message to a specific address - all consumers receive the messages.
3. `send` a message and expect reply

[source, java]
----
// Case 1
bus.send("address", "hello");
// Case 2
bus.publish("address", "hello");
// Case 3
bus.send("address", "hello, how are you?").thenAccept(message -> {
    // reponse
});
----

== Putting things together - bridging HTTP and messages

Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.
It uses the request/reply dispatching mechanism.

Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.
This message is consumed by another bean and the response is sent using the _reply_ mechanism.

Let's implement this. Creates a new JAX-RS resource with the following content:

[source,java]
----
package org.acme;

import io.vertx.axle.core.eventbus.EventBus;
import io.vertx.axle.core.eventbus.Message;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import java.util.concurrent.CompletionStage;

@Path("/hello")
public class EventResource {

    @Inject EventBus bus;

    @GET
    @Path("/async/{name}")
    public CompletionStage<String> hello(@PathParam("name") String name) {
        return bus.<String>send("my-address", name)
                .thenApply(Message::body);
    }
}
----

Now we need a consumer listening on the `my-address` address. Create a `GreetingService` bean with the following content:

[source, java]
----
package org.acme;

import io.quarkus.vertx.ConsumeEvent;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {

    @ConsumeEvent("my-address")
    public String hello(String name) {
        return "Hello " + name;
    }

}
----

This bean receives the name, and return the greeting message.
