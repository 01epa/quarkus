package org.jboss.shamrock.maven;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;
import org.jboss.shamrock.deployment.ClassOutput;
import org.jboss.shamrock.deployment.Runner;

@Mojo(name = "build", defaultPhase = LifecyclePhase.PREPARE_PACKAGE, requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)
public class ShamrockMojo extends AbstractMojo {

    /**
     * The directory for compiled classes.
     */
    @Parameter(readonly = true, required = true, defaultValue = "${project.build.outputDirectory}")
    private File outputDirectory;

    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    protected MavenProject project;

    /**
     * The directory for classes generated by processing.
     */
    @Parameter(defaultValue = "${project.build.directory}/wiring-classes")
    private File wiringClassesDirectory;

    @Parameter(defaultValue = "${project.build.directory}")
    private File buildDir;
    /**
     * The directory for library jars
     */
    @Parameter(defaultValue = "${project.build.directory}/lib")
    private File libDir;

    @Parameter(defaultValue = "${project.build.finalName}")
    private String finalName;


    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        final byte[] buffer = new byte[8000];
        libDir.mkdirs();
        wiringClassesDirectory.mkdirs();
        try {
            StringBuilder classPath = new StringBuilder();
            classPath.append(finalName + ".jar");

            for (Artifact a : project.getArtifacts()) {
                try (ZipFile zip = new ZipFile(a.getFile())) {
                    if (zip.getEntry("META-INF/services/org.jboss.shamrock.deployment.ResourceProcessor") == null) {
                        try (FileInputStream in = new FileInputStream(a.getFile())) {
                            File file = new File(libDir, a.getFile().getName());
                            try (FileOutputStream out = new FileOutputStream(file)) {
                                int r;
                                while ((r = in.read(buffer)) > 0) {
                                    out.write(buffer, 0, r);
                                }
                            }
                            classPath.append(" lib/" + file.getName());
                        }
                    }
                }
            }

            List<URL> classPathUrls = new ArrayList<>();
            for(Artifact artifact : project.getArtifacts()) {
                classPathUrls.add(artifact.getFile().toURL());
            }

            //we need to make sure all the deployment artifacts are on the class path
            //to do this we need to create a new class loader to actually use for the runner
            URLClassLoader runnerClassLoader = new URLClassLoader(classPathUrls.toArray(new URL[0]), getClass().getClassLoader());
            Runner runner = new Runner(new ClassOutput() {
                @Override
                public void writeClass(String className, byte[] data) throws IOException {
                    String location = className.replace('.', '/');
                    File file = new File(wiringClassesDirectory, location + ".class");
                    file.getParentFile().mkdirs();
                    try (FileOutputStream out = new FileOutputStream(file)) {
                        out.write(data);
                    }
                }
            }, runnerClassLoader);


            runner.run(outputDirectory.toPath());

            try (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(new File(buildDir, finalName + "-runner.jar")))) {
                Path wiringJar = Paths.get(wiringClassesDirectory.getAbsolutePath());
                Files.walk(wiringJar).forEach(new Consumer<Path>() {
                    @Override
                    public void accept(Path path) {
                        try {
                            String pathName = wiringJar.relativize(path).toString();
                            if (Files.isDirectory(path)) {
                                out.putNextEntry(new ZipEntry(pathName + "/"));
                            } else {
                                out.putNextEntry(new ZipEntry(pathName));
                                try (FileInputStream in = new FileInputStream(path.toFile())) {
                                    int r;
                                    while ((r = in.read(buffer)) > 0) {
                                        out.write(buffer, 0, r);
                                    }
                                }
                            }
                        } catch (Exception e) {
                            throw new RuntimeException(e);
                        }
                    }
                });
                Manifest manifest = new Manifest();
                manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
                manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH, classPath.toString());
                manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS, "org.jboss.shamrock.runner.Main");
                out.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF"));
                manifest.write(out);
            }

        } catch (Exception e) {
            throw new MojoFailureException("Failed to run", e);
        }
    }
}
