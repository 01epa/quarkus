include::./attributes.adoc[]
= {project-name} - Using Eclipse Vert.x

Eclipse https://vertx.io[Vert.x] is a toolkit for building reactive applications.
It is designed to be lightweight and embeddable.
Quarkus integrates Vert.x to implement different forms of reactive features.
Basically, {project-name} uses Vert.x as its reactive engine.
While lots of reactive feature from {project-name} don't _show_ Vert.x, it's used underneath.
But you can also access the managed Vert.x instance and benefits from the Vert.x ecosystem.

== Installing

To access Vert.x, well, you need to enable the `vertx` extension to use this feature.
If you are creating a new project, set the `extensions` parameter are follows:

[source, subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=vertx-quickstart \
    -Dextensions="vert.x"
----

If you have an already created project, the `vertx` extension can be added to an existing {project-name} project with
the `add-extension` command:

[source]
----
mvn quarkus:add-extension -Dextensions="vertx"
----

Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:

[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-vertx</artifactId>
</dependency>
----

=== Reactive web resources

{project-name} web resources support asynchronous processing and streaming results over https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[server-sent events].

==== Asynchronous processing

Most programming guides start easy with a greeting service and this one makes no exception.

To asynchronously greet a client, the endpoint method must return a `java.util.concurrent.CompletionStage`:

[source,java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("{name}")
    public CompletionStage<String> greeting(@PathParam("name") String name) {
        // When complete, return the content to the client
        CompletableFuture<String> future = new CompletableFuture<>();

        long start = System.nanoTime();

        // TODO: asynchronous greeting

        return future;
    }
}
----

So far so good.
Now let's use the Vert.x API to implement the delayed reply with the `setTimer` provided by Vert.x:

[source,java]
----
// Delay reply by 10ms
vertx.setTimer(10, l -> {
    // Compute elapsed time in milliseconds
    long duration = MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS);

    // Format message
    String message = String.format("Hello %s! (%d ms)%n", name, duration);

    // Complete
    future.complete(message);
});
----

Nothing fancy.
But you may wonder how to get the `io.vertx.axle.core.Vertx` instance?
After the `vertx` extension is installed, you can `@Inject` one in any {project-name} bean:

[source,java]
----
@Inject
Vertx vertx;
----

NOTE: If you are a Vert.x user you may wonder about this `io.vertx.axle.core.Vertx`.
We are going to cover this later in this guide. You can also have a bare `io.vertx.core.Vertx` instance or an RX Java 2 instance `io.vertx.reactivex.core.Vertx`.

That's it.
Now start {project-name} in `dev` mode with:

[source]
----
mvn compile quarkus:dev
----

Eventually, open your browser and navigate to http://localhost:8080/hello/Quarkus, you should see:

[source]
----
Hello Quarkus! (10 ms)
----

==== Streaming using Server-Sent Events

{project-name} web resources that need to send content as https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[server-sent events] must have a method:

- declaring the `text/event-stream` response content type
- returning a https://www.reactive-streams.org/[Reactive Streams] `Publisher`

In practice, a streaming greeting service would look like:

[source,java]
----
@Path("/hello")
public class StreamingResource {

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @Path("{name}/streaming")
    public Publisher<String> greeting(@PathParam("name") String name) {
        // TODO: create a Reactive Streams publisher
        return publisher;
    }
}
----

How to create a Reactive Streams publisher?
There are a few ways to do this:

1. If you use `io.vertx.axle.core.Vertx`, the API provides `toPublisher` methods (and then use RX Java 2 or Reactive Streams Operators to manipulate the stream)
2. You can also use `io.vertx.reactivex.core.Vertx` which already provides RX Java 2 (RX Java 2 `Flowable` implement Reactive Streams `publisher`).

The first approach can be implemented as follows:

[source, java]
----
// Use io.vertx.axle.core.Vertx;
@Inject Vertx vertx;

@GET
@Produces(MediaType.SERVER_SENT_EVENTS)
@Path("{name}/streaming")
public Publisher<String> greeting(@PathParam("name") String name) {
    return Flowable
            .fromPublisher(vertx.periodicStream(2000).toPublisher())
            .map(l -> String.format("Hello %s! (%s)%n", name, new Date()));
}
----

The second approach uses a different "injected" type:

[source,java]
----
// Use io.vertx.reactivex.core.Vertx;
@Inject Vertx vertx;

@GET
@Produces(MediaType.SERVER_SENT_EVENTS)
@Path("{name}/streaming")
public Publisher<String> greeting(@PathParam("name") String name) {
    return vertx.periodicStream(2000).toFlowable()
            .map(l -> String.format("Hello %s! (%s)%n", name, new Date()));
}
----

The server side is ready.
In order to see the result in the browser, we need a web page.

[source,html]
.META-INF/resources/streaming.html
----
<!doctype html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>SSE with Vert.x - Quarkus</title>
    <script type="application/javascript" src="streaming.js"></script>
</head>
<body>
<div id="container"></div>
</body>
</html>
----

Our web page just has an empty `<div>` container.
The magic, as always, lies in the Javascript code:

[source,javascript]
.META-INF/resources/streaming.js
----
var eventSource = new EventSource("/hello/Quarkus/streaming");
eventSource.onmessage = function (event) {
    var container = document.getElementById("container");
    var paragraph = document.createElement("p");
    paragraph.innerHTML = event.data;
    container.appendChild(paragraph);
};
----

IMPORTANT: Most browsers support SSE but some don't.
More about this in  Mozilla's https://developer.mozilla.org/en-US/docs/Web/API/EventSource#Browser_compatibility[SSE browser-compatibility list].

Navigate to http://localhost:8080/streaming.html.
A new greeting should show-up every 2 seconds.

[source]
----
Hello Quarkus! (Thu Mar 21 17:26:12 CET 2019)

Hello Quarkus! (Thu Mar 21 17:26:14 CET 2019)

Hello Quarkus! (Thu Mar 21 17:26:16 CET 2019)

...
----

==== Using JSON results

Vert.x API heavily relies on JSON, namely the `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray` types.
They are both supported as {project-name} web resource return types.

Consider these endpoints:

[source,java]
----
@Path("/hello")
@Produces(MediaType.APPLICATION_JSON)
public class VertxJsonResource {

    @GET
    @Path("{name}/object")
    public JsonObject jsonObject(@PathParam("name") String name) {
        return new JsonObject().put("Hello", name);
    }

    @GET
    @Path("{name}/array")
    public JsonArray jsonArray(@PathParam("name") String name) {
        return new JsonArray().add("Hello").add(name);
    }
}
----

In your browser, navigate to http://localhost:8080/hello/Quarkus/object. You should see:

[source]
----
{"Hello":"Quarkus"}
----

Then, navigate to http://localhost:8080/hello/Quarkus/array:

[source]
----
["Hello","Quarkus"]
----

Needless to say, this works equally well when the JSON result is wrapped in a `CompletionStage` or a `Publisher`.

== Using the Reactive clients

TODO: talk about the existing clients, in particular the Axle shims

=== Web Client

TODO


//////
It comes from another Vert.x shim, _Axle_, similar to the _Rxified_ one, but that uses the `CompletionStage` type for single results and `Publisher` for streams.

TIP: You may inject any of the 3 flavors of `Vertx` or `EventBus` in your {project-name} application beans: `core`, `Axle`, `RxJava`.
They are just shims and rely on a single Vert.x instance.

You will pick one or the other depending on your use cases.

- `core`: for advanced usage or if you have existing Vert.x code you want to reuse in your {project-name} application
- `Axle`: works well with {project-name} and Microprofile APIs (`CompletionStage` for single results and `Publisher` for streams)
- `RxJava`: when you need support for a wide range of data transformation operators on your streams
//////
